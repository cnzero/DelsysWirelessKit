### 初衷
这是一次有意义的尝试。

最开始一直想做对程序尽量进行模块化，但始终囿于自己代码能力——所阅读的较好的代码太少，一直没有找到切入点。
前段时间，为了能够快速打造“基于Python的Machine Learning的Pipeline”，去从[sklearn]()进行了突击，初步看了下PCA与LDA，主要这两种方法一直在用；基本上可以说，算法的原理没有太大的问题，花点时间，无论什么编程语言总能够实现，但是实现起来的结果也是有好坏的，从模块化的角度讲，是否易用等。 看了sklearn中利用面向对象将数据与方法的统一，还是很受启发的。

之前自己所谓模块化的思想更多局限在“函数的封装”层面，完全是面向过程的思路，其中要特别规范化输入-输出接口，而这如果在一开始没有一定高度，有很大一步到位，每次面对不同的需求，总是在修改。所以，修改了很多次都没有满意的模块化结果。

所以，这次受到sklearn中算法的启发，决定利用类似的思路，在MATLAB上重造轮子试试。


#### 启发
在看了几个模型算法后（比如LDA，PCA），能够明显看到一些共性的东西，比如就methods而言，一般都有class的实例化，`fit`, `fit_transform`, `predict` 等。

再想想一般机器学习的思路，这一点就非常好理解：
1. 设置所使用的模型内部参数；
2. 拿到训练样本（有标签或无标签的）对所选择的模型进行训练，确定其中关键参数；
3. 利用已经训练完成的模型，对测试样本进行判别，以得到模型的正确率等评价指标；


#### 审视LDA-class
既然理解了上述思路，再回头看看这个LDA-class（LDA.m）：
1. 必要的参数以及相关变量等，都放到`properties`，此处不对`properties`做进一步的约束，如`public` or `private` 等；
2. class的实例化，用于初始化模型必要的参数；
3. 必要的方法：trainM(), judge()
    用于模型训练与样本矩阵判别

并且，以后所有的机器学习模型，都至少包含以上几个部分，然后根据模型本身的特点，再添加必要的`properties` 与 `methods`

### 后记

第一个问题：_我为什么要在这里重复造轮子？_
1. 我觉得确实必要性不是特别大，所以加快自己的进度，将对Machine Learning的研究尽快转换到Python及其开源库上；
2. 既然现在造了轮子，也是有意义的。
    1. 当自己亲自去造轮子的时候，才发现其难度，以及暴露自己的水平；
    2. 当自己造的轮子不好时，才更能明确自己的差距在哪里；
    3. 没有什么是“理所应当”与“自然而然”的，尤其是当自己想从坑里爬出来的时候；
    4. 感受那一步步的思路转换。