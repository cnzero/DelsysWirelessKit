### 初衷
这是一次有意义的尝试。

最开始一直想做对程序尽量进行模块化，但始终囿于自己代码能力——所阅读的较好的代码太少，一直没有找到切入点。
前段时间，为了能够快速打造“基于Python的Machine Learning的Pipeline”，去从[sklearn](http://scikit-learn.org/stable/modules/generated/sklearn.decomposition.PCA.html)进行了突击，初步看了下PCA与LDA，主要这两种方法一直在用；基本上可以说，算法的原理没有太大的问题，花点时间，无论什么编程语言总能够实现，但是实现起来的结果也是有好坏的. 比如，从模块化的角度讲，是否易用等。 看了sklearn中利用面向对象将数据与方法的统一，还是很受启发的。

之前自己所谓模块化的思想更多局限在“函数的封装”层面，完全是面向过程的思路，其中要特别规范化输入-输出接口，而这如果在一开始没有一定高度，有很难一步到位，每次面对不同的需求，总是在修改。所以，修改了很多次都没有满意的模块化结果。

所以，这次受到sklearn中程序封装的启发，决定利用类似的思路，在MATLAB上重造轮子试试。


#### 启发
在看了几个模型算法后（比如LDA，PCA），能够明显看到一些共性的东西，比如就methods而言，一般都有class的实例化，`fit`, `fit_transform`, `predict` 等。

再想想一般机器学习的思路，这一点就非常好理解：
1. 设置所使用的模型内部参数；
2. 拿到训练样本（有标签或无标签的）对所选择的模型进行训练，确定其中关键参数；
3. 利用已经训练完成的模型，对测试样本进行判别，以得到模型的正确率等评价指标；


#### 审视LDA-class
既然理解了上述思路，再回头看看这个LDA-class（LDA.m）：
1. 必要的参数以及相关变量等，都放到`properties`，此处不对`properties`做进一步的约束，如`public` or `private` 等；
    1. `n_components` 降维后的空间维数；
    2. `samplesCell` 训练样本，为一个cell，其中每个元素为同一个类别的样本矩阵，样本矩阵中每一行表示在特征空间中的样本点；
    3. `projectM` 投影矩阵，对任意样本或样本矩阵降维，可直接写成 `X * projectM`
    4. `explained_variance_ratio` 既然是利用特征值排序筛选出来的特征向量，就给出所选出的最大特征值（个数取决于`n_components`）占所有的百分比；
    5. `means` 原始训练样本的类中心，维度为`n_classes X n_features`
    6. `accuracyMatrix` 维度为 `n_classes X n_classes` 能够知道训练样本中的样本被分类的结果，既包括正确分类，也包括错误分类的结果；
        __特别说明：__ 由于LDA这类算法模型本身并没有需要调节的参数，关键的也就是降维空间维数，不需要一个调参过程，因此也就将 _训练集/测试集_ 对比的过程忽略掉了，也就是偷懒仅仅给出训练集的精度。
2. __events__：
    1. 还是“事件驱动”的固有思路。这里表示的意义是，一旦得到测试样本的判别结果，则通知订阅函数。在一定程度上是实现解耦，而不是直接性的参数传递，至少在程序空间中做了一定的松绑与解耦。
3. __methods__:
    1. `LDA()` 相当于是 _构造函数_ 完成对模型参数的基本配置；
    2. `trainM()` 模型训练过程；
    3. `SimpleTrainM()` 实际上没有任何降维操作，就完全是一个在特征空间中利用欧氏距离的分类器；
    4. `reduct` 对样本或样本矩阵进行降维；
    3. `Judge()` 对测试样本或样本矩阵的分类判断；
    4. `GetAccuracy()` 得到训练样本的错误分类矩阵;

并且，以后所有的机器学习模型，都至少包含以上几个部分，然后根据模型本身的特点，再添加必要的`properties` 与 `methods`。这种思想也算是从“面向过程”到“面向对象”的过渡：如果想对原来的基础进行更新，“面向过程”要适当增添函数的输入输出参数，还很难保证对原有情况的兼容；而“面向对象”直接在类的基础上增添“properties”与“methods”并不影响原有情况的使用。
这一点，“面向对象”更像是累积性地搭积木，而“面向过程”是每次都得推倒重来，好烦人。

__Attentions__
1. 在上述整理文档的过程中也很容易发现，虽然在整体思想上能够比较顺利地构造出可用的`LDA-class`， 但是许多细节之处还是得修改，修改得更规范一些。由此，想到给自己提几条建议：
2. 先写文档，明白需求。 类似上面一样， 先把`properties` `events` `methods` 这三部分明确，确定合适、望文知义的变量命名，先作整体把握。
3. 一般的约束：
    1. `properties` 首字母小写，在注释中明确数据类型，维数等信息；
    2. `events` 以`event` 开头；
    3. `methods` 首字母大写；
4. 转向Python的最开始就要时刻提醒自己OOP。

#### 从封装函数到面向对象
##### Procedure Oriented
1. 可理解为按部就班的干活，强调的是“动作”，至于动作执行者、处理的对象、处理结果可以看做该“动作”的输入输出；
2. 但有时候一个活儿要干很多遍，会在很多地方重复使用，也许只是改一改输入或输出参数的问题，那就是一些常见“动作”的封装，并取适当的参数；
3. 但有时候，虽然了解当前的“动作”需求，固定了参数内容与意义，但是往往遇到新的情况，就会对旧的“动作”输入输出做一定的修改，修改的时候就要考虑到对旧情况的兼容，这包括：输入输出参数内容、个数等。其中一个 _小技巧_，可以将所有的参数都绑定到一个结构体上，这样输入输出就可以固定为“一个”参数，在不同的情况去查询该结构体的不同字段即可；
4. 如果再深入思考，封装“动作”的同时，更深入地进行“抽象”， 我觉得这是一个非常难的活儿，自己还没有较好的实践训练。
5. 另外一方面，我既然在“动作”执行过程中可以把潜在的参数都绑定到一个结构体上，那我为什么不能将一些必要的“动作”也绑定到 __某种东西__ 上呢？
6. 我这样引导自己去思考，思考出来的结果就是OOP-Object-Oriented Programming。
    这里 __某种东西__ 就是类或者类的实例化，其既绑定了属性，也绑定了“动作”方法，并且能够对这些内容进行不同的权限管理。


##### OOP - Object-Oriented Programming
1. OK，由上可知，现在我本能地对OOP有了实际的初步需求：将属性与方法绑定到类中。
而完全不像大二学C++的时候，那时候学了一个学期的OOP，也纠结了一个学期，我为什么要用这个OOP，并且其中封装、继承与多态的特性一直是云里雾里的。就好像，那时候有人给我扔了一个好东西，但我一直是拒绝的；直到现在，我才明白，然后去主动拥抱它。
2. 而下一步，结合OOP封装、继承与多态的特性，继续从实际需求出发，探讨OOP的益处。


### 后记

第一个问题：_我为什么要在这里重复造轮子？_
1. 我觉得确实必要性不是特别大，所以加快自己的进度，将对Machine Learning的研究尽快转换到Python及其开源库上；
2. 既然现在造了轮子，也是有意义的。
    1. 当自己亲自去造轮子的时候，才发现其难度，以及暴露自己的水平；
    2. 当自己造的轮子不好时，才更能明确自己的差距在哪里；
    3. 没有什么是“理所应当”与“自然而然”的，尤其是当自己想从坑里爬出来的时候；
    4. 感受那一步步的思路转换。