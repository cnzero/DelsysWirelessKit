#### 目的
对诸多假肢手的一个进行底层封装，并适当封装成上层易用的接口。 

#### 假肢手SolidWorks图示
五个手指共14个关节，其中大拇指为2个关节；

#### 电机与关节分布图
（最开始并没有认真考虑电机序号与手指关节的顺序问题）

#### 控制通信说明
这是诸多假肢手的一款，暂定命名为 __GHand__。
目前其 _机械部分_ 前期由 __高锟林__，后期由 __冯晓斌__ 负责；

控制部分也由两人使用淘宝卖家所提供的rios_usc.exe GUI程序通过设置，实现了一系列动作的执行——这种方法仅仅能假肢手的控制，但如果与其他系统相结合，还需要一些程序接口的东西；
庆幸的是，其底层硬件板子是一直在监听上位机的串口通信；当然其文档也说明了串口通信所发送的字符串解析方法。
所以，利用串口通信的接口，就能够实现上位机对该控制板及其所带的十四个舵机进行控制。
同时，有观察到该底层控制板留出了串口蓝牙的接口，所以一步到位，上位机与底层通过蓝牙通信；针对上位机电脑而言，只需要安装一个USB的串口蓝牙，必要的情况下使用 _驱动精灵_ 安装必要的驱动程序。仔细观察所发送的字符串格式，能够容易实现串口通信。 

#### 操作说明
1. 正常手部的电池供电，开关开机；
2. 电脑端插入USB的串口蓝牙，蓝牙将立即闪烁配对， 配对完成则灯常亮；
3. 直接运行 `testRandomMove.m` 脚本，能够看到手指在Rock、Paper、Scissor三个动作间随机运动，运动速度也算比较满意。 

#### 代码说明
为了从底层到上层一层层地进行封装，每一层都有着不同的意义
##### 第一层：关节及其直接的驱动电机
`fingerThumb.m` `fingerFore.m` `fingerMiddle.m` `fingerRing.m` `fingerLittle.m`
`function fingerThumb(LINK, n, p, t)` 作为最底层相当于对各个关节及其直接的驱动电机进行控制命令，并为了与下一层`finger`进行较好的过渡，该函数封装成这种形式：
1. LINK表示串口设备的句柄；
2. n表示该手指的第n个关节，每个手指有三个关节（大拇指有两个关节），从手部到之间方向依次为1-2-3；
3. p表示位置，由于舵机只能在0-180°范围内进行旋转，并为了保证驱动线的预紧与完全收缩，需要根据实际机械安装等进行实际匹配；
4. t表示完成p位置所需的时间——并不可以作为完全可靠的参考，但也具有很大的参考意义

__function fingerThumb(LINK, n, p, t)__ 其中存在的一些问题：
针对单一的关节进行直接驱动时，在程序中也就意味着直接对串口设备发送对应的字符串；
如果对多个关节进行同时控制：
1. 
    ```
    fingerThumb(LINK, 1, p, t);
    fingerThumb(LINK, 2, p, t);
    fingerThumb(LINK, 3, p, t);
    ```
    最初以为三个关节能够运动，并且忽略指令发送时间，三个关节应该几乎同时运动；
    可记过并非如此，真实运动测试中，只有第一条命令真正被执行，后面的置零完全忽略——除非在每条指令后面添加足够的延时；
    所以，这样的话，行不通不好用；
2. 根据串口发送字符串的文档说明，当同时对多个电机控制时，先将必要的、正确的字符串进行拼接，最后统一发送；
    所以，这也就是上述五个手指的封装函数，都有一个对应string的函数：`fingerThumb.m` `fingerFore.m` `fingerMiddle.m` `fingerRing.m` `fingerLittle.m`
`function fingerThumb(LINK, n, p, t)`  每个函数内不再直接对串口进行字符串发送而是先输出必要的电机驱动字符串，最终在下一层进行发送与执行；

#### 第二层：手指
#### 第三层：手部整体性动作
目前已经封装完成了
1. 石头-Rcok    - `smoveRock.m`
2. 剪刀-Paper   - `smovePaper.m`
3.  布 -Scissor - `smoveScissor.m`

对应也有`moveRock.m` `movePaper.m` `moveScissor.m` 都不好使，就是遇到了前面所指的问题。 

